# План Реализации: Архитектура Секций Чекаута

## 1. Цель

Реализовать гибкую и масштабируемую архитектуру для секций чекаута, в которой `SectionContainer` выступает в роли универсального контроллера состояния, а вся бизнес-логика и работа с данными инкапсулируется на уровне конкретной секции.

## 2. Обзор Архитектуры

Мы пришли к следующей архитектуре с четким разделением ответственности:

-   **`SectionContainer.tsx`**: **Универсальный Контейнер.** (`src/modules/checkout/components/section/SectionContainer.tsx`)
    -   Управляет состоянием валидности секции (`valid`/`invalid`) через хук `useSectionController`.
    -   **Не знает ничего** о содержании, данных или операциях секции.
    -   Принимает `selector` для извлечения данных, `Component` для отображения и `operations` для выполнения действий.
    -   Передает в `Component` подготовленные данные и колбэки операций.

-   **`makeSection(...)`**: **Фабрика Секций.**
    -   Является точкой конфигурации, где все части собираются вместе.
    -   Здесь мы определяем `id` секции, `selector`, `Component` (View), `operations` и функцию `isSectionValid`.

-   **`Selector`**: **Трансформер Данных.**
    -   Функция, которая служит мостом между глобальным состоянием (`checkout data` в `zustand`) и `View`.
    -   Ее задача — извлечь, смапить и трансформировать сырые данные из `checkout` в четко определенную структуру, понятную для `View` (например, в `DeliveryFormData`).

-   **`Operations`**: **Действия с Данными.**
    -   Объект, содержащий асинхронные функции (обычно обернутые в хуки), которые инкапсулируют GraphQL-мутации.
    -   Примеры: `updateAddress(data)`, `selectDeliveryMethod(id)`.
    -   Эти функции отвечают за отправку данных на бэкенд и обновление глобального стора `zustand` в случае успеха.

-   **`isSectionValid`**: **Валидатор Состояния.**
    -   Чистая функция, которая принимает `checkout` и возвращает `true` или `false`.
    -   Определяет, является ли секция валидной, основываясь на данных, **уже подтвержденных бэкендом**.

-   **`Component` (View)**: **"Глупый" Компонент Отображения.**
    -   Получает на вход смапленные данные и набор `operations`.
    -   Отвечает исключительно за рендеринг UI.
    -   При действиях пользователя (ввод в поле, клик по кнопке) вызывает соответствующие `operations`.
    -   При начале редактирования любого поля вызывает колбэк `onDirty()`, чтобы немедленно пометить секцию как невалидную.

---

## 3. Пошаговый План Реализации

### Шаг 1: Финализация `SectionContainer`

**Задача:** Убедиться, что `SectionContainer` соответствует финальной "прозрачной" архитектуре. Мы добавим ему возможность принимать `operations` и `isSectionValid`.

**Действия:**
1.  Открыть `src/modules/checkout/components/section/SectionContainer.tsx`.
2.  Обновить его код, чтобы он принимал `operations` и `isSectionValid`, а также передавал их вместе с `onDirty` в дочерний `Component`. (Я предоставлю точный код для этого шага).

### Шаг 2: Определение Типов для Секции Доставки

**Задача:** Создать четкие контракты данных и операций для секции доставки.

**Действия:**
1.  Открыть `src/modules/checkout/sections/delivery/types.ts`.
2.  Определить интерфейс `DeliveryFormData` — это структура данных, которую будет получать `View`. Она будет содержать все необходимое для рендеринга: список провайдеров, выбранный метод, данные для полей формы и т.д.
3.  Определить интерфейс `DeliveryOperations` — это типы для колбэков, которые мы будем передавать. Например:
    ```typescript
    interface DeliveryOperations {
      onAddressUpdate: (address: AddressInput) => Promise<void>;
      onMethodSelect: (methodId: string) => Promise<void>;
    }
    ```

### Шаг 3: Реализация Хуков Операций

**Задача:** Создать хуки, которые инкапсулируют GraphQL-мутации для секции доставки.

**Действия:**
1.  Создать новый файл `src/modules/checkout/sections/delivery/hooks.ts`.
2.  Внутри создать и экспортировать хуки, соответствующие `DeliveryOperations`:
    -   `useUpdateDeliveryAddress()`: Использует мутацию для обновления адреса. Внутри вызывает `commitMutation`, а в `onCompleted` обновляет `checkoutStore`.
    -   `useSelectDeliveryMethod()`: Аналогично для выбора метода доставки.

### Шаг 4: Сборка Секции в `makeSection`

**Задача:** Сконфигурировать `DeliverySection`, соединив все части вместе.

**Действия:**
1.  Открыть `src/modules/checkout/sections/delivery/components/Container.tsx`.
2.  Внутри вызова `makeSection<DeliveryFormData, DeliveryOperations>({...})`:
    -   **`selector`**: Написать функцию, которая принимает `state: CheckoutState` и возвращает `DeliveryFormData`. Эта функция будет выполнять всю логику по трансформации сырых `checkout` данных в удобную для `View` структуру.
    -   **`isSectionValid`**: Написать чистую функцию, которая принимает `checkout` и проверяет, что все необходимые данные для доставки уже сохранены и валидны (например, `checkout.deliveryAddress` не `null` и содержит все нужные поля).
    -   **`useOperations`**: Создать небольшой хук `useDeliveryOperations`, который внутри вызывает хуки из Шага 3 (`useUpdateDeliveryAddress` и др.) и возвращает их в виде объекта, соответствующего интерфейсу `DeliveryOperations`.

### Шаг 5: Адаптация `View`-компонентов

**Задача:** Упростить `DeliverySectionView` и его дочерние компоненты, чтобы они соответствовали "глупой" архитектуре.

**Действия:**
1.  Открыть `src/modules/checkout/sections/delivery/components/Component.tsx` (компонент `DeliverySectionView`).
2.  Изменить его пропсы, чтобы он принимал `data: DeliveryFormData`, `onDirty`, и операции из `DeliveryOperations`.
3.  Удалить из него всю внутреннюю логику и управление состоянием.
4.  Подключить UI-элементы к колбэкам:
    -   `onChange` или `onFocus` на полях ввода должны вызывать `onDirty()`.
    -   `onBlur` или клик по кнопке "Сохранить" должны собирать данные формы и вызывать соответствующую операцию (например, `props.onAddressUpdate(formData)`).
5.  Пробросить необходимые данные и операции дальше вниз до компонентов-провайдеров (`src/modules/checkout/vendors/novaposta/components/ShippingProvider.tsx`) и компонентов-методов (например, `src/modules/checkout/vendors/novaposta/components/AddressDelivery.tsx`). Они также станут значительно проще, так как их единственной задачей будет рендеринг и вызов колбэков, полученных сверху.

После выполнения этих шагов мы получим чистую, предсказуемую и легко тестируемую архитектуру для секции доставки, которую затем можно будет применить и к остальным секциям чекаута.
